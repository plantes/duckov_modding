# 逃离鸭科夫 Mod 编译经验总结

**基于 HeadshotTip Mod 的完整编译经验**

---

## 📋 目录

1. [编译环境配置](#编译环境配置)
2. [常见问题及解决方案](#常见问题及解决方案)
3. [项目配置要点](#项目配置要点)
4. [依赖管理](#依赖管理)
5. [输出文件处理](#输出文件处理)
6. [最佳实践](#最佳实践)

---

## 编译环境配置

### 必需组件

1. **.NET SDK 8.0+**
   - 下载：https://dotnet.microsoft.com/download/dotnet/8.0
   - 验证安装：`dotnet --version`
   - **重要**：即使安装了 Visual Studio 2022，也可能需要单独安装 .NET SDK

2. **Visual Studio 2022（可选）**
   - 工作负载：
     - ✓ .NET 桌面开发
     - ✓ .NET Core 跨平台开发
   - 包含组件：
     - MSBuild
     - NuGet 包管理器

3. **游戏本体**
   - 需要引用游戏 DLL 文件
   - 路径：`{游戏目录}\Duckov_Data\Managed\`

### 编译方式选择

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **dotnet CLI** | 跨平台、轻量、命令行友好 | 需要手动复制依赖 DLL | 自动化脚本、CI/CD |
| **Visual Studio** | 图形界面、调试方便 | 体积大、仅 Windows | 开发调试阶段 |
| **MSBuild** | 功能强大、配置灵活 | 需要 VS 环境 | 复杂构建需求 |

**推荐**：开发时用 Visual Studio，发布时用 dotnet CLI

---

## 常见问题及解决方案

### 问题 1：找不到 Microsoft.NET.Sdk

**错误信息**：
```
error : 无法解析 SDK"Microsoft.NET.Sdk"
error MSB4236: 找不到指定的 SDK"Microsoft.NET.Sdk"
```

**原因**：
- Visual Studio 缺少 .NET SDK 组件
- MSBuild 找不到 .NET SDK 路径

**解决方案**：

**方案 A（推荐）**：安装 .NET SDK
```bash
# 下载并安装 .NET SDK 8.0
# https://dotnet.microsoft.com/download/dotnet/8.0

# 验证安装
dotnet --version
```

**方案 B**：在 Visual Studio Installer 中添加组件
1. 打开 Visual Studio Installer
2. 修改 → 勾选 ".NET 桌面开发" 和 ".NET Core 跨平台开发"
3. 安装

**方案 C**：直接使用 dotnet CLI 编译
```bash
dotnet build ProjectName.sln -c Release
```

---

### 问题 2：找不到游戏 DLL（UnityEngine、Duckov 等）

**错误信息**：
```
error CS0246: 未能找到类型或命名空间名"UnityEngine"
error CS0246: 未能找到类型或命名空间名"Duckov"
```

**原因**：
- .csproj 中的游戏路径配置错误
- 游戏未安装或路径不存在

**解决方案**：

1. **找到正确的游戏路径**

   Steam 版本：
   - 右键游戏 → 管理 → 浏览本地文件
   - 通常在：`Steam\steamapps\common\Escape from Duckov`

   其他版本：
   - 记下包含 `Duckov.exe` 的目录路径

2. **修改 .csproj 文件**

   打开 `YourMod.csproj`，找到：
   ```xml
   <DuckovPath>旧的路径</DuckovPath>
   ```

   改为：
   ```xml
   <DuckovPath>你的实际游戏路径</DuckovPath>
   ```

3. **验证路径**

   确保以下文件夹存在：
   ```
   {游戏路径}\Duckov_Data\Managed\
   ```

   应包含：
   - UnityEngine.dll
   - Assembly-CSharp.dll
   - TeamSoda.*.dll

---

### 问题 3：找不到 UniTask（Cysharp 命名空间）

**错误信息**：
```
error CS0246: 未能找到类型或命名空间名"Cysharp"
```

**原因**：
- .csproj 中没有引用 UniTask.dll
- UniTask 不在通配符引用范围内

**解决方案**：

在 .csproj 的 `<ItemGroup>` 中添加：
```xml
<Reference Include="$(DuckovPath)$(SubPath)UniTask.dll">
    <Private>False</Private>
</Reference>
```

**完整示例**：
```xml
<ItemGroup>
    <Reference Include="$(DuckovPath)$(SubPath)TeamSoda.*">
        <Private>False</Private>
    </Reference>
    <Reference Include="$(DuckovPath)$(SubPath)Unity*">
        <Private>False</Private>
    </Reference>
    <Reference Include="$(DuckovPath)$(SubPath)UniTask.dll">
        <Private>False</Private>
    </Reference>
</ItemGroup>
```

---

### 问题 4：编译成功但找不到依赖 DLL

**症状**：
- 编译成功
- 只生成了主 DLL（如 HeadshotTip.dll）
- 缺少 0Harmony.dll、Newtonsoft.Json.dll

**原因**：
- NuGet 包的 DLL 不会自动复制到输出目录
- `<Private>False</Private>` 设置阻止了复制

**解决方案**：

**方案 A（推荐）**：手动复制脚本
```bash
# 找到 NuGet 包位置
# Windows: C:\Users\{用户名}\.nuget\packages

# 复制 Harmony
cp "$HOME/.nuget/packages/lib.harmony/2.4.1/lib/net472/0Harmony.dll" ./output/

# 复制 Newtonsoft.Json
cp "$HOME/.nuget/packages/newtonsoft.json/13.0.3/lib/netstandard2.0/Newtonsoft.Json.dll" ./output/
```

**方案 B**：修改 .csproj，自动复制
```xml
<ItemGroup>
    <PackageReference Include="Lib.Harmony" Version="2.4.1">
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    </PackageReference>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3">
        <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    </PackageReference>
</ItemGroup>
```

**方案 C**：Post-Build 事件
```xml
<Target Name="CopyDependencies" AfterTargets="Build">
    <Copy SourceFiles="$(NuGetPackageRoot)lib.harmony\2.4.1\lib\net472\0Harmony.dll"
          DestinationFolder="$(OutputPath)" />
    <Copy SourceFiles="$(NuGetPackageRoot)newtonsoft.json\13.0.3\lib\netstandard2.0\Newtonsoft.Json.dll"
          DestinationFolder="$(OutputPath)" />
</Target>
```

---

### 问题 5：DLL 被放在子文件夹中（如 netstandard2.1/）

**症状**：
- 输出路径：`ReleaseExample\HeadshotTip\netstandard2.1\HeadshotTip.dll`
- 预期路径：`ReleaseExample\HeadshotTip\HeadshotTip.dll`

**原因**：
- .NET SDK 默认在输出路径下创建框架子文件夹

**解决方案**：

**方案 A**：修改 .csproj
```xml
<PropertyGroup>
    <OutputPath>ReleaseExample\HeadshotTip\</OutputPath>
    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
</PropertyGroup>
```

**方案 B**：Post-Build 移动
```xml
<Target Name="MoveOutput" AfterTargets="Build">
    <Move SourceFiles="$(OutputPath)netstandard2.1\$(TargetFileName)"
          DestinationFolder="$(OutputPath)" />
</Target>
```

**方案 C**：手动复制脚本
```bash
cp "ReleaseExample/HeadshotTip/netstandard2.1/HeadshotTip.dll" "ReleaseExample/HeadshotTip/"
```

---

## 项目配置要点

### 完整的 .csproj 配置模板

```xml
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <!-- 目标框架 -->
        <TargetFramework>netstandard2.1</TargetFramework>
        <Nullable>enable</Nullable>

        <!-- 游戏路径配置 -->
        <DuckovPath>E:\Your\Game\Path\Escape from Duckov</DuckovPath>
        <SubPath>\Duckov_Data\Managed\</SubPath>

        <!-- 输出配置 -->
        <OutputPath>ReleaseExample\YourModName\</OutputPath>
        <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    </PropertyGroup>

    <ItemGroup>
        <!-- NuGet 依赖 -->
        <PackageReference Include="Lib.Harmony" Version="2.4.1" />
        <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
    </ItemGroup>

    <ItemGroup>
        <!-- 游戏 DLL 引用 -->
        <Reference Include="$(DuckovPath)$(SubPath)TeamSoda.*">
            <Private>False</Private>
        </Reference>
        <Reference Include="$(DuckovPath)$(SubPath)ItemStatsSystem.dll">
            <Private>False</Private>
        </Reference>
        <Reference Include="$(DuckovPath)$(SubPath)Unity*">
            <Private>False</Private>
        </Reference>
        <Reference Include="$(DuckovPath)$(SubPath)UniTask.dll">
            <Private>False</Private>
        </Reference>
    </ItemGroup>

    <!-- 自动复制依赖（可选） -->
    <Target Name="CopyDependencies" AfterTargets="Build">
        <ItemGroup>
            <HarmonyDll Include="$(NuGetPackageRoot)lib.harmony\2.4.1\lib\net472\0Harmony.dll" />
            <JsonDll Include="$(NuGetPackageRoot)newtonsoft.json\13.0.3\lib\netstandard2.0\Newtonsoft.Json.dll" />
        </ItemGroup>
        <Copy SourceFiles="@(HarmonyDll)" DestinationFolder="$(OutputPath)" />
        <Copy SourceFiles="@(JsonDll)" DestinationFolder="$(OutputPath)" />
    </Target>
</Project>
```

### 关键配置说明

1. **TargetFramework**
   - 必须是 `netstandard2.1`
   - 与游戏 Unity 版本兼容

2. **DuckovPath**
   - 灵活配置，支持不同安装位置
   - 使用绝对路径

3. **Private=False**
   - 防止复制游戏 DLL 到输出
   - 减小 Mod 体积

4. **OutputPath**
   - 直接输出到发布目录
   - 方便测试和部署

---

## 依赖管理

### NuGet 包

**必需依赖**：
- **Lib.Harmony 2.4.1**
  - 用于运行时方法 Patch
  - 选择版本：net472（兼容性最好）

- **Newtonsoft.Json 13.0.3**
  - JSON 配置文件解析
  - 选择版本：netstandard2.0

**可选依赖**：
- UniTask（游戏自带）
- DOTween（游戏自带）

### 包版本选择原则

1. **Harmony**
   - 使用 2.x 版本（不要用 1.x）
   - net472 或 netstandard2.0

2. **JSON 库**
   - Newtonsoft.Json（推荐）
   - 避免 System.Text.Json（Unity 不完全支持）

3. **Unity 相关**
   - 优先使用游戏自带 DLL
   - 避免通过 NuGet 安装 Unity 库

### NuGet 包位置

**Windows**：
```
C:\Users\{用户名}\.nuget\packages\
├── lib.harmony\
│   └── 2.4.1\
│       └── lib\
│           ├── net35\
│           ├── net452\
│           ├── net472\
│           └── netstandard2.0\
└── newtonsoft.json\
    └── 13.0.3\
        └── lib\
            ├── net45\
            ├── netstandard2.0\
            └── ...
```

---

## 输出文件处理

### Mod 完整文件清单

一个完整的 Mod 应包含：

```
YourModName/
├── YourModName.dll        # 主程序（必需）
├── 0Harmony.dll           # Harmony 库（必需）
├── Newtonsoft.Json.dll    # JSON 库（可选，如果用到）
├── config.json            # 配置文件（推荐）
├── info.ini               # Mod 信息（必需）
└── preview.png            # 预览图（推荐）
```

### info.ini 格式

```ini
name = YourModName
displayName = 你的Mod显示名称
description = Mod 功能描述
tags = Quality of Life,Visual Enhancements
```

### 文件大小参考

| 文件 | 典型大小 | 说明 |
|------|----------|------|
| YourMod.dll | 10-50 KB | 主程序代码 |
| 0Harmony.dll | ~2.4 MB | Harmony 库 |
| Newtonsoft.Json.dll | ~689 KB | JSON 库 |
| config.json | <1 KB | 配置文件 |
| info.ini | <1 KB | Mod 信息 |
| preview.png | 50-200 KB | 预览图 |

---

## 最佳实践

### 编译流程

**推荐的完整编译流程**：

```bash
# 1. 清理旧输出
dotnet clean

# 2. 还原 NuGet 包
dotnet restore

# 3. 编译项目
dotnet build -c Release

# 4. 复制依赖 DLL
# （如果没有自动复制）
cp ~/.nuget/packages/lib.harmony/2.4.1/lib/net472/0Harmony.dll ./output/
cp ~/.nuget/packages/newtonsoft.json/13.0.3/lib/netstandard2.0/Newtonsoft.Json.dll ./output/

# 5. 复制主 DLL
# （如果在子文件夹中）
cp ./output/netstandard2.1/YourMod.dll ./output/

# 6. 清理临时文件
rm -rf ./output/netstandard2.1
rm ./output/*.pdb
rm ./output/*.deps.json
```

### 自动化脚本

**build.bat 示例**：
```batch
@echo off
echo 开始编译...

REM 编译项目
dotnet build YourMod.sln -c Release

if %ERRORLEVEL% NEQ 0 (
    echo 编译失败！
    pause
    exit /b 1
)

REM 复制依赖
set OUTPUT=YourMod\ReleaseExample\YourMod
copy "%USERPROFILE%\.nuget\packages\lib.harmony\2.4.1\lib\net472\0Harmony.dll" "%OUTPUT%\"
copy "%USERPROFILE%\.nuget\packages\newtonsoft.json\13.0.3\lib\netstandard2.0\Newtonsoft.Json.dll" "%OUTPUT%\"

REM 移动主 DLL
if exist "%OUTPUT%\netstandard2.1\YourMod.dll" (
    copy "%OUTPUT%\netstandard2.1\YourMod.dll" "%OUTPUT%\"
    rmdir /s /q "%OUTPUT%\netstandard2.1"
)

echo 编译成功！
pause
```

### 版本控制

**.gitignore 配置**：
```gitignore
# 编译输出
bin/
obj/
*.dll
*.pdb
*.deps.json

# 除了最终输出的 DLL
!ReleaseExample/*/*.dll

# NuGet
packages/
*.nupkg

# Visual Studio
.vs/
*.user
*.suo
```

### 测试流程

1. **编译后立即测试**
   ```bash
   # 自动部署到游戏
   ./deploy.bat

   # 启动游戏测试
   ```

2. **日志查看**
   ```bash
   # 查看 Mod 加载日志
   ./view-logs.bat
   ```

3. **快速迭代**
   - 修改代码
   - 重新编译
   - 自动部署
   - 重启游戏测试

### 发布清单

发布前检查：
- [ ] 所有必需 DLL 都在
- [ ] info.ini 信息正确
- [ ] preview.png 存在且美观
- [ ] config.json 有默认值
- [ ] 在游戏中测试通过
- [ ] 日志无错误
- [ ] 清理了调试文件（.pdb）

---

## 常用命令速查

```bash
# 查看 .NET 版本
dotnet --version

# 清理项目
dotnet clean

# 还原 NuGet 包
dotnet restore

# 编译（Debug）
dotnet build

# 编译（Release）
dotnet build -c Release

# 发布（单文件）
dotnet publish -c Release

# 查看 NuGet 包位置
dotnet nuget locals all --list

# 查看项目引用
dotnet list reference
```

---

## 故障排查清单

编译失败时按以下顺序检查：

1. ✓ .NET SDK 是否安装？
   ```bash
   dotnet --version
   ```

2. ✓ 游戏路径是否正确？
   - 检查 .csproj 中的 `<DuckovPath>`
   - 验证路径存在且包含 Duckov.exe

3. ✓ 游戏 DLL 是否存在？
   - 检查 `{游戏路径}\Duckov_Data\Managed\`
   - 确认有 UnityEngine.dll、Assembly-CSharp.dll

4. ✓ NuGet 包是否还原？
   ```bash
   dotnet restore
   ```

5. ✓ 项目配置是否完整？
   - TargetFramework = netstandard2.1
   - 所有必需的 Reference

6. ✓ 代码是否有语法错误？
   - 查看错误列表
   - 逐个修复编译错误

7. ✓ 依赖 DLL 是否复制？
   - 检查输出文件夹
   - 手动复制 NuGet 包 DLL

---

## 总结

### 关键经验

1. **环境配置是基础**
   - .NET SDK 必须单独安装
   - Visual Studio 不等于 .NET SDK

2. **游戏路径要正确**
   - 每个人的安装路径可能不同
   - 要灵活配置

3. **依赖管理要清晰**
   - NuGet 包不会自动复制
   - 需要手动处理或配置自动复制

4. **输出结构要规范**
   - 所有 DLL 在同一目录
   - 包含配置和资源文件

5. **测试要及时**
   - 编译成功 ≠ 运行正常
   - 必须在游戏中实际测试

### 推荐工具链

- **代码编辑**：Visual Studio 2022 / VS Code
- **编译**：dotnet CLI
- **反编译**：ILSpy / dnSpy
- **调试**：Unity Log / dnSpy
- **版本控制**：Git
- **文档**：Markdown

---

**更新日期**：2025-11-27
**基于项目**：HeadshotTip Mod v1.0
**游戏版本**：逃离鸭科夫 v1.0.26
